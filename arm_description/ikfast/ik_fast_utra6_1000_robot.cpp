/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004b generated on 2022-10-22 02:20:00.042344
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "/usr/local/lib/python2.7/dist-packages/openravepy/_openravepy_0_53/ikfast.h"
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION == 0x1000004b);

#include <algorithm>
#include <cmath>
#include <complex>
#include <limits>
#include <vector>

#ifndef IKFAST_ASSERT
#include <iostream>
#include <sstream>
#include <stdexcept>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b)                                                                                          \
  {                                                                                                               \
    if (!(b)) {                                                                                                   \
      std::stringstream ss;                                                                                       \
      ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " << __PRETTY_FUNCTION__ << ": Assertion '" \
         << #b << "' failed";                                                                                     \
      throw std::runtime_error(ss.str());                                                                         \
    }                                                                                                             \
  }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI ((IkReal)6.28318530717959)
#define IKPI ((IkReal)3.14159265358979)
#define IKPI_2 ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif  // _MSC_VER

// lapack routines
extern "C" {
void dgetrf_(const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
void zgetrf_(const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
void dgesv_(const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
void dgetrs_(const char* trans, const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b,
             const int* ldb, int* info);
void dgeev_(const char* jobvl, const char* jobvr, const int* n, double* a, const int* lda, double* wr, double* wi,
            double* vl, const int* ldvl, double* vr, const int* ldvr, double* work, const int* lwork, int* info);
}

using namespace std;  // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f * f; }
inline double IKsqr(double f) { return f * f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and
// evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they
// can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH \
  ((IkReal)0.03)  // 5D IK has some crazy degenerate cases, but can rely on jacobian refinment to make better, just need
                  // good starting point
#endif

inline float IKasin(float f) {
  IKFAST_ASSERT(f > -1 - IKFAST_SINCOS_THRESH &&
                f < 1 + IKFAST_SINCOS_THRESH);  // any more error implies something is wrong with the solver
  if (f <= -1)
    return float(-IKPI_2);
  else if (f >= 1)
    return float(IKPI_2);
  return asinf(f);
}
inline double IKasin(double f) {
  IKFAST_ASSERT(f > -1 - IKFAST_SINCOS_THRESH &&
                f < 1 + IKFAST_SINCOS_THRESH);  // any more error implies something is wrong with the solver
  if (f <= -1)
    return -IKPI_2;
  else if (f >= 1)
    return IKPI_2;
  return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y) {
  while (x < 0) {
    x += y;
  }
  return fmodf(x, y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y) {
  while (x < 0) {
    x += y;
  }
  return fmod(x, y);
}

inline float IKacos(float f) {
  IKFAST_ASSERT(f > -1 - IKFAST_SINCOS_THRESH &&
                f < 1 + IKFAST_SINCOS_THRESH);  // any more error implies something is wrong with the solver
  if (f <= -1)
    return float(IKPI);
  else if (f >= 1)
    return float(0);
  return acosf(f);
}
inline double IKacos(double f) {
  IKFAST_ASSERT(f > -1 - IKFAST_SINCOS_THRESH &&
                f < 1 + IKFAST_SINCOS_THRESH);  // any more error implies something is wrong with the solver
  if (f <= -1)
    return IKPI;
  else if (f >= 1)
    return 0;
  return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) {
  if (f <= 0.0f) return 0.0f;
  return sqrtf(f);
}
inline double IKsqrt(double f) {
  if (f <= 0.0) return 0.0;
  return sqrt(f);
}
inline float IKatan2Simple(float fy, float fx) { return atan2f(fy, fx); }
inline float IKatan2(float fy, float fx) {
  if (isnan(fy)) {
    IKFAST_ASSERT(!isnan(fx));  // if both are nan, probably wrong value will be returned
    return float(IKPI_2);
  } else if (isnan(fx)) {
    return 0;
  }
  return atan2f(fy, fx);
}
inline double IKatan2Simple(double fy, double fx) { return atan2(fy, fx); }
inline double IKatan2(double fy, double fx) {
  if (isnan(fy)) {
    IKFAST_ASSERT(!isnan(fx));  // if both are nan, probably wrong value will be returned
    return IKPI_2;
  } else if (isnan(fx)) {
    return 0;
  }
  return atan2(fy, fx);
}

template <typename T>
struct CheckValue {
  T value;
  bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon) {
  CheckValue<T> ret;
  ret.valid = false;
  ret.value = 0;
  if (!isnan(fy) && !isnan(fx)) {
    if (IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH) {
      ret.value = IKatan2Simple(fy, fx);
      ret.valid = true;
    }
  }
  return ret;
}

inline float IKsign(float f) {
  if (f > 0) {
    return float(1);
  } else if (f < 0) {
    return float(-1);
  }
  return 0;
}

inline double IKsign(double f) {
  if (f > 0) {
    return 1.0;
  } else if (f < 0) {
    return -1.0;
  }
  return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n) {
  CheckValue<T> ret;
  ret.valid = true;
  if (n == 0) {
    ret.value = 1.0;
    return ret;
  } else if (n == 1) {
    ret.value = f;
    return ret;
  } else if (n < 0) {
    if (f == 0) {
      ret.valid = false;
      ret.value = (T)1.0e30;
      return ret;
    }
    if (n == -1) {
      ret.value = T(1.0) / f;
      return ret;
    }
  }

  int num = n > 0 ? n : -n;
  if (num == 2) {
    ret.value = f * f;
  } else if (num == 3) {
    ret.value = f * f * f;
  } else {
    ret.value = 1.0;
    while (num > 0) {
      if (num & 1) {
        ret.value *= f;
      }
      num >>= 1;
      f *= f;
    }
  }

  if (n < 0) {
    ret.value = T(1.0) / ret.value;
  }
  return ret;
}

template <typename T>
struct ComplexLess {
  bool operator()(const complex<T>& lhs, const complex<T>& rhs) const {
    if (real(lhs) < real(rhs)) {
      return true;
    }
    if (real(lhs) > real(rhs)) {
      return false;
    }
    return imag(lhs) < imag(rhs);
  }
};

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
  IkReal x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23,
      x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46;
  x0 = IKcos(j[0]);
  x1 = IKcos(j[1]);
  x2 = IKcos(j[2]);
  x3 = IKsin(j[1]);
  x4 = IKsin(j[2]);
  x5 = IKsin(j[3]);
  x6 = IKcos(j[3]);
  x7 = IKcos(j[5]);
  x8 = IKsin(j[5]);
  x9 = IKcos(j[4]);
  x10 = IKsin(j[4]);
  x11 = IKsin(j[0]);
  x12 = ((0.4325) * x2);
  x13 = ((0.0745) * x6);
  x14 = ((0.1045) * x11);
  x15 = ((1.0) * x10);
  x16 = ((1.0) * x11);
  x17 = ((1.0) * x9);
  x18 = ((0.0745) * x5);
  x19 = (x0 * x3);
  x20 = (x0 * x9);
  x21 = (x11 * x9);
  x22 = (x3 * x4);
  x23 = (x1 * x2);
  x24 = (x2 * x3);
  x25 = (x1 * x4);
  x26 = (x11 * x3);
  x27 = (x11 * x15);
  x28 = ((1.0) * x25);
  x29 = (x0 * x25);
  x30 = (x22 + x23);
  x31 = ((((-1.0) * x28)) + x24);
  x32 = (x30 * x5);
  x33 = (x31 * x6);
  x34 = ((((-1.0) * x19 * x2)) + x29);
  x35 = (((x0 * x23)) + ((x19 * x4)));
  x36 = ((((-1.0) * x16 * x24)) + ((x11 * x25)));
  x37 = (x11 * ((x22 + x23)));
  x38 = (x36 * x5);
  x39 = (x33 + x32);
  x40 = (((x5 * (((((-1.0) * x24)) + x28)))) + ((x30 * x6)));
  x41 = (((x34 * x5)) + ((x35 * x6)));
  x42 = (x38 + ((x37 * x6)));
  x43 = (((x34 * x6)) + ((x5 * (((((-1.0) * x0 * x23)) + (((-1.0) * x19 * x4)))))));
  IkReal x47 = ((1.0) * x16);
  x44 = (((x5 * (((((-1.0) * x22 * x47)) + (((-1.0) * x23 * x47)))))) + ((x36 * x6)));
  x45 = (x42 * x9);
  x46 = (x41 * x9);
  eerot[0] = (((x43 * x8)) + ((x7 * (((((-1.0) * x27)) + x46)))));
  eerot[1] = (((x8 * (((((-1.0) * x17 * x41)) + x27)))) + ((x43 * x7)));
  eerot[2] = (((x10 * x41)) + x21);
  IkReal x48 = ((0.1045) * x19);
  eetrans[0] =
      (((x5 * (((((-0.1045) * x0 * x23)) + (((-1.0) * x4 * x48)))))) + (((-0.463) * x19)) + (((-1.0) * x12 * x19)) +
       (((0.0745) * x21)) + (((0.1405) * x11)) + ((x6 * (((((0.1045) * x29)) + (((-1.0) * x2 * x48)))))) +
       ((x10 * ((((x18 * x34)) + ((x13 * x35)))))) + (((0.4325) * x29)));
  eerot[3] = (((x7 * ((((x0 * x10)) + x45)))) + ((x44 * x8)));
  eerot[4] = (((x8 * (((((-1.0) * x0 * x15)) + (((-1.0) * x17 * x42)))))) + ((x44 * x7)));
  eerot[5] = (((x10 * x42)) + (((-1.0) * x0 * x17)));
  IkReal x49 = ((1.0) * x14);
  eetrans[1] = (((x10 * ((((x18 * x36)) + ((x13 * x37)))))) + (((-0.463) * x26)) + (((0.4325) * x11 * x25)) +
                (((-1.0) * x12 * x26)) + (((-0.0745) * x20)) + ((x6 * ((((x14 * x25)) + (((-1.0) * x24 * x49)))))) +
                ((x5 * (((((-1.0) * x22 * x49)) + (((-1.0) * x23 * x49)))))) + (((-0.1405) * x0)));
  eerot[6] = (((x40 * x8)) + ((x39 * x7 * x9)));
  eerot[7] = (((x40 * x7)) + ((x8 * x9 * (((((-1.0) * x33)) + (((-1.0) * x32)))))));
  eerot[8] = (x10 * x39);
  eetrans[2] = ((0.1175) + ((x10 * ((((x18 * x30)) + ((x13 * x31)))))) + ((x1 * x12)) +
                ((x5 * (((((0.1045) * x25)) + (((-0.1045) * x24)))))) + (((0.4325) * x22)) + (((0.463) * x1)) +
                ((x6 * (((((0.1045) * x23)) + (((0.1045) * x22)))))));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API const int* GetFreeIndices() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
 public:
  IkReal j0, cj0, sj0, htj0, j0mul, j1, cj1, sj1, htj1, j1mul, j2, cj2, sj2, htj2, j2mul, j3, cj3, sj3, htj3, j3mul, j4,
      cj4, sj4, htj4, j4mul, j5, cj5, sj5, htj5, j5mul, new_r00, r00, rxp0_0, new_r01, r01, rxp0_1, new_r02, r02,
      rxp0_2, new_r10, r10, rxp1_0, new_r11, r11, rxp1_1, new_r12, r12, rxp1_2, new_r20, r20, rxp2_0, new_r21, r21,
      rxp2_1, new_r22, r22, rxp2_2, new_px, px, npx, new_py, py, npy, new_pz, pz, npz, pp;
  unsigned char _ij0[2], _nj0, _ij1[2], _nj1, _ij2[2], _nj2, _ij3[2], _nj3, _ij4[2], _nj4, _ij5[2], _nj5;

  IkReal j100, cj100, sj100;
  unsigned char _ij100[2], _nj100;
  bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree,
                 IkSolutionListBase<IkReal>& solutions) {
    j0 = numeric_limits<IkReal>::quiet_NaN();
    _ij0[0] = -1;
    _ij0[1] = -1;
    _nj0 = -1;
    j1 = numeric_limits<IkReal>::quiet_NaN();
    _ij1[0] = -1;
    _ij1[1] = -1;
    _nj1 = -1;
    j2 = numeric_limits<IkReal>::quiet_NaN();
    _ij2[0] = -1;
    _ij2[1] = -1;
    _nj2 = -1;
    j3 = numeric_limits<IkReal>::quiet_NaN();
    _ij3[0] = -1;
    _ij3[1] = -1;
    _nj3 = -1;
    j4 = numeric_limits<IkReal>::quiet_NaN();
    _ij4[0] = -1;
    _ij4[1] = -1;
    _nj4 = -1;
    j5 = numeric_limits<IkReal>::quiet_NaN();
    _ij5[0] = -1;
    _ij5[1] = -1;
    _nj5 = -1;
    for (int dummyiter = 0; dummyiter < 1; ++dummyiter) {
      solutions.Clear();
      r00 = eerot[0 * 3 + 0];
      r01 = eerot[0 * 3 + 1];
      r02 = eerot[0 * 3 + 2];
      r10 = eerot[1 * 3 + 0];
      r11 = eerot[1 * 3 + 1];
      r12 = eerot[1 * 3 + 2];
      r20 = eerot[2 * 3 + 0];
      r21 = eerot[2 * 3 + 1];
      r22 = eerot[2 * 3 + 2];
      px = eetrans[0];
      py = eetrans[1];
      pz = eetrans[2];

      new_r00 = r00;
      new_r01 = r01;
      new_r02 = r02;
      new_px = ((((-0.0745) * r02)) + px);
      new_r10 = r10;
      new_r11 = r11;
      new_r12 = r12;
      new_py = ((((-0.0745) * r12)) + py);
      new_r20 = r20;
      new_r21 = r21;
      new_r22 = r22;
      new_pz = ((-0.1175) + (((-0.0745) * r22)) + pz);
      r00 = new_r00;
      r01 = new_r01;
      r02 = new_r02;
      r10 = new_r10;
      r11 = new_r11;
      r12 = new_r12;
      r20 = new_r20;
      r21 = new_r21;
      r22 = new_r22;
      px = new_px;
      py = new_py;
      pz = new_pz;
      IkReal x50 = ((1.0) * px);
      IkReal x51 = ((1.0) * pz);
      IkReal x52 = ((1.0) * py);
      pp = ((px * px) + (py * py) + (pz * pz));
      npx = (((px * r00)) + ((py * r10)) + ((pz * r20)));
      npy = (((px * r01)) + ((py * r11)) + ((pz * r21)));
      npz = (((px * r02)) + ((py * r12)) + ((pz * r22)));
      rxp0_0 = ((((-1.0) * r20 * x52)) + ((pz * r10)));
      rxp0_1 = (((px * r20)) + (((-1.0) * r00 * x51)));
      rxp0_2 = ((((-1.0) * r10 * x50)) + ((py * r00)));
      rxp1_0 = ((((-1.0) * r21 * x52)) + ((pz * r11)));
      rxp1_1 = (((px * r21)) + (((-1.0) * r01 * x51)));
      rxp1_2 = ((((-1.0) * r11 * x50)) + ((py * r01)));
      rxp2_0 = (((pz * r12)) + (((-1.0) * r22 * x52)));
      rxp2_1 = (((px * r22)) + (((-1.0) * r02 * x51)));
      rxp2_2 = ((((-1.0) * r12 * x50)) + ((py * r02)));
      {
        IkReal j0eval[2];
        j0eval[0] = ((px * px) + (py * py));
        j0eval[1] = ((IKabs(px)) + (IKabs(py)));
        if (IKabs(j0eval[0]) < 0.0000010000000000 || IKabs(j0eval[1]) < 0.0000010000000000) {
          continue;  // no branches [j0]

        } else {
          {
            IkReal j0array[2], cj0array[2], sj0array[2];
            bool j0valid[2] = {false};
            _nj0 = 2;
            CheckValue<IkReal> x55 = IKatan2WithCheck(IkReal(((-1.0) * py)), IkReal(px), IKFAST_ATAN2_MAGTHRESH);
            if (!x55.valid) {
              continue;
            }
            IkReal x53 = ((1.0) * (x55.value));
            if ((((px * px) + (py * py))) < -0.00001) continue;
            CheckValue<IkReal> x56 = IKPowWithIntegerCheck(IKabs(IKsqrt(((px * px) + (py * py)))), -1);
            if (!x56.valid) {
              continue;
            }
            if ((((0.1405) * (x56.value))) < -1 - IKFAST_SINCOS_THRESH ||
                (((0.1405) * (x56.value))) > 1 + IKFAST_SINCOS_THRESH)
              continue;
            IkReal x54 = IKasin(((0.1405) * (x56.value)));
            j0array[0] = (x54 + (((-1.0) * x53)));
            sj0array[0] = IKsin(j0array[0]);
            cj0array[0] = IKcos(j0array[0]);
            j0array[1] = ((3.14159265358979) + (((-1.0) * x53)) + (((-1.0) * x54)));
            sj0array[1] = IKsin(j0array[1]);
            cj0array[1] = IKcos(j0array[1]);
            if (j0array[0] > IKPI) {
              j0array[0] -= IK2PI;
            } else if (j0array[0] < -IKPI) {
              j0array[0] += IK2PI;
            }
            j0valid[0] = true;
            if (j0array[1] > IKPI) {
              j0array[1] -= IK2PI;
            } else if (j0array[1] < -IKPI) {
              j0array[1] += IK2PI;
            }
            j0valid[1] = true;
            for (int ij0 = 0; ij0 < 2; ++ij0) {
              if (!j0valid[ij0]) {
                continue;
              }
              _ij0[0] = ij0;
              _ij0[1] = -1;
              for (int iij0 = ij0 + 1; iij0 < 2; ++iij0) {
                if (j0valid[iij0] && IKabs(cj0array[ij0] - cj0array[iij0]) < IKFAST_SOLUTION_THRESH &&
                    IKabs(sj0array[ij0] - sj0array[iij0]) < IKFAST_SOLUTION_THRESH) {
                  j0valid[iij0] = false;
                  _ij0[1] = iij0;
                  break;
                }
              }
              j0 = j0array[ij0];
              cj0 = cj0array[ij0];
              sj0 = sj0array[ij0];

              {
                IkReal j5array[2], cj5array[2], sj5array[2];
                bool j5valid[2] = {false};
                _nj5 = 2;
                IkReal x57 = cj0 * cj0;
                IkReal x58 = r01 * r01;
                IkReal x59 = r00 * r00;
                IkReal x60 = ((1.0) * sj0);
                IkReal x61 = ((4.0) * x59);
                IkReal x62 = ((8.0) * cj0 * sj0);
                IkReal x63 = ((4.0) * x58);
                IkReal x64 = ((4.0) * x57);
                CheckValue<IkReal> x69 = IKPowWithIntegerCheck(((((-1.0) * r01 * x60)) + ((cj0 * r11))), -1);
                if (!x69.valid) {
                  continue;
                }
                IkReal x65 = x69.value;
                IkReal x66 = (cj0 * r10 * x65);
                CheckValue<IkReal> x70 = IKPowWithIntegerCheck(((((-1.0) * r01 * sj0)) + ((cj0 * r11))), -1);
                if (!x70.valid) {
                  continue;
                }
                IkReal x67 = (r00 * x60 * (x70.value));
                if (((((x64 * (r11 * r11))) + (((-1.0) * r00 * r10 * x62)) + ((x64 * (r10 * r10))) + x61 + x63 +
                      (((-1.0) * r01 * r11 * x62)) + (((-1.0) * x57 * x63)) + (((-1.0) * x57 * x61)))) < -0.00001)
                  continue;
                IkReal x68 =
                    ((0.5) * x65 *
                     (IKsqrt((((x64 * (r11 * r11))) + (((-1.0) * r00 * r10 * x62)) + ((x64 * (r10 * r10))) + x61 + x63 +
                              (((-1.0) * r01 * r11 * x62)) + (((-1.0) * x57 * x63)) + (((-1.0) * x57 * x61))))));
                j5array[0] = ((2.0) * (atan((x66 + x68 + (((-1.0) * x67))))));
                sj5array[0] = IKsin(j5array[0]);
                cj5array[0] = IKcos(j5array[0]);
                j5array[1] = ((-2.0) * (atan((x67 + x68 + (((-1.0) * x66))))));
                sj5array[1] = IKsin(j5array[1]);
                cj5array[1] = IKcos(j5array[1]);
                if (j5array[0] > IKPI) {
                  j5array[0] -= IK2PI;
                } else if (j5array[0] < -IKPI) {
                  j5array[0] += IK2PI;
                }
                j5valid[0] = true;
                if (j5array[1] > IKPI) {
                  j5array[1] -= IK2PI;
                } else if (j5array[1] < -IKPI) {
                  j5array[1] += IK2PI;
                }
                j5valid[1] = true;
                for (int ij5 = 0; ij5 < 2; ++ij5) {
                  if (!j5valid[ij5]) {
                    continue;
                  }
                  _ij5[0] = ij5;
                  _ij5[1] = -1;
                  for (int iij5 = ij5 + 1; iij5 < 2; ++iij5) {
                    if (j5valid[iij5] && IKabs(cj5array[ij5] - cj5array[iij5]) < IKFAST_SOLUTION_THRESH &&
                        IKabs(sj5array[ij5] - sj5array[iij5]) < IKFAST_SOLUTION_THRESH) {
                      j5valid[iij5] = false;
                      _ij5[1] = iij5;
                      break;
                    }
                  }
                  j5 = j5array[ij5];
                  cj5 = cj5array[ij5];
                  sj5 = sj5array[ij5];
                  htj5 = IKtan(j5 / 2);

                  {
                    IkReal j2array[2], cj2array[2], sj2array[2];
                    bool j2valid[2] = {false};
                    _nj2 = 2;
                    cj2array[0] = ((-1.02434549744691) + (((2.49691007378369) * pp)) +
                                   (((-0.521854205420792) * cj5 * npy)) + (((-0.521854205420792) * npx * sj5)));
                    if (cj2array[0] >= -1 - IKFAST_SINCOS_THRESH && cj2array[0] <= 1 + IKFAST_SINCOS_THRESH) {
                      j2valid[0] = j2valid[1] = true;
                      j2array[0] = IKacos(cj2array[0]);
                      sj2array[0] = IKsin(j2array[0]);
                      cj2array[1] = cj2array[0];
                      j2array[1] = -j2array[0];
                      sj2array[1] = -sj2array[0];
                    } else if (isnan(cj2array[0])) {
                      // probably any value will work
                      j2valid[0] = true;
                      cj2array[0] = 1;
                      sj2array[0] = 0;
                      j2array[0] = 0;
                    }
                    for (int ij2 = 0; ij2 < 2; ++ij2) {
                      if (!j2valid[ij2]) {
                        continue;
                      }
                      _ij2[0] = ij2;
                      _ij2[1] = -1;
                      for (int iij2 = ij2 + 1; iij2 < 2; ++iij2) {
                        if (j2valid[iij2] && IKabs(cj2array[ij2] - cj2array[iij2]) < IKFAST_SOLUTION_THRESH &&
                            IKabs(sj2array[ij2] - sj2array[iij2]) < IKFAST_SOLUTION_THRESH) {
                          j2valid[iij2] = false;
                          _ij2[1] = iij2;
                          break;
                        }
                      }
                      j2 = j2array[ij2];
                      cj2 = cj2array[ij2];
                      sj2 = sj2array[ij2];
                      {
                        IkReal evalcond[1];
                        IkReal x71 = (cj5 * sj0);
                        IkReal x72 = ((0.096767) * pp);
                        IkReal x73 = ((0.193534) * npy);
                        IkReal x74 = (cj0 * cj5);
                        IkReal x75 = (sj0 * sj5);
                        IkReal x76 = ((0.193534) * npx);
                        IkReal x77 = (cj0 * sj5);
                        evalcond[0] =
                            ((-0.05337413776075) + ((py * x73 * x74)) + ((r01 * x71 * x72)) +
                             (((-1.0) * px * x71 * x73)) + ((r00 * x72 * x75)) + ((py * x76 * x77)) +
                             (((-0.052105600985) * (IKcos(j2)))) + (((-1.0) * r11 * x72 * x74)) + (((0.130103) * pp)) +
                             (((-1.0) * px * x75 * x76)) + (((-1.0) * r10 * x72 * x77)));
                        if (IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH) {
                          continue;
                        }
                      }

                      {
                        IkReal j3eval[2];
                        j3eval[0] = ((-1.00232275059614) + (((-1.0) * cj2)));
                        j3eval[1] = IKsign(((-83897877.25) + (((-83703455.0) * cj2))));
                        if (IKabs(j3eval[0]) < 0.0000010000000000 || IKabs(j3eval[1]) < 0.0000010000000000) {
                          continue;  // no branches [j1, j3, j4]

                        } else {
                          {
                            IkReal j3array[1], cj3array[1], sj3array[1];
                            bool j3valid[1] = {false};
                            _nj3 = 1;
                            IkReal x78 = ((96767000.0) * cj5);
                            IkReal x79 = (sj0 * sj2);
                            IkReal x80 = (cj0 * rxp1_1);
                            IkReal x81 = ((96767000.0) * cj2);
                            IkReal x82 = ((90392500.0) * cj5);
                            IkReal x83 = ((463000000.0) * pp);
                            IkReal x84 = (rxp1_0 * sj0);
                            IkReal x85 = (rxp0_0 * sj0 * sj5);
                            IkReal x86 = (cj0 * rxp0_1 * sj5);
                            CheckValue<IkReal> x87 =
                                IKPowWithIntegerCheck(IKsign(((-83897877.25) + (((-83703455.0) * cj2)))), -1);
                            if (!x87.valid) {
                              continue;
                            }
                            CheckValue<IkReal> x88 = IKatan2WithCheck(
                                IkReal(((((-1.0) * x81 * x86)) + (((-1.0) * sj2 * x83)) + (((-1.0) * x80 * x82)) +
                                        (((-1.0) * cj2 * x78 * x80)) + ((x82 * x84)) + ((cj2 * x78 * x84)) +
                                        ((x81 * x85)) + (((90392500.0) * x85)) + (((200055702.25) * sj2)) +
                                        (((-90392500.0) * x86)) + (((185429185.0) * cj2 * sj2)))),
                                IkReal(((186877086.875) + (((-96767000.0) * rxp0_0 * sj5 * x79)) +
                                        (((-1.0) * rxp1_0 * x78 * x79)) + ((sj2 * x78 * x80)) +
                                        (((373269789.75) * cj2)) + (((185429185.0) * (cj2 * cj2))) +
                                        (((-432500000.0) * pp)) + (((96767000.0) * sj2 * x86)) +
                                        (((-1.0) * cj2 * x83)))),
                                IKFAST_ATAN2_MAGTHRESH);
                            if (!x88.valid) {
                              continue;
                            }
                            j3array[0] = ((-1.5707963267949) + (((1.5707963267949) * (x87.value))) + (x88.value));
                            sj3array[0] = IKsin(j3array[0]);
                            cj3array[0] = IKcos(j3array[0]);
                            if (j3array[0] > IKPI) {
                              j3array[0] -= IK2PI;
                            } else if (j3array[0] < -IKPI) {
                              j3array[0] += IK2PI;
                            }
                            j3valid[0] = true;
                            for (int ij3 = 0; ij3 < 1; ++ij3) {
                              if (!j3valid[ij3]) {
                                continue;
                              }
                              _ij3[0] = ij3;
                              _ij3[1] = -1;
                              for (int iij3 = ij3 + 1; iij3 < 1; ++iij3) {
                                if (j3valid[iij3] && IKabs(cj3array[ij3] - cj3array[iij3]) < IKFAST_SOLUTION_THRESH &&
                                    IKabs(sj3array[ij3] - sj3array[iij3]) < IKFAST_SOLUTION_THRESH) {
                                  j3valid[iij3] = false;
                                  _ij3[1] = iij3;
                                  break;
                                }
                              }
                              j3 = j3array[ij3];
                              cj3 = cj3array[ij3];
                              sj3 = sj3array[ij3];
                              {
                                IkReal evalcond[4];
                                IkReal x89 = IKcos(j3);
                                IkReal x90 = IKsin(j3);
                                IkReal x91 = (px * sj0);
                                IkReal x92 = ((0.463) * sj2);
                                IkReal x93 = ((1.0) * sj5);
                                IkReal x94 = (pp * sj0);
                                IkReal x95 = (cj0 * py);
                                IkReal x96 = (cj0 * pp);
                                IkReal x97 = ((1.0) * cj5);
                                IkReal x98 = ((2.0) * cj5 * npy);
                                IkReal x99 = (cj2 * x89);
                                IkReal x100 = (sj2 * x90);
                                IkReal x101 = ((2.0) * npx * sj5);
                                evalcond[0] = ((0.43208575) + (((0.400495) * cj2)) + (((-1.0) * pp)) +
                                               (((0.096767) * x99)) + (((0.0903925) * x89)) + (((0.096767) * x100)));
                                evalcond[1] = ((0.1045) + (((0.4325) * x89)) + ((x90 * x92)) + (((0.463) * x99)) +
                                               (((-1.0) * npy * x97)) + (((-1.0) * npx * x93)));
                                evalcond[2] = (((x89 * x92)) + (((-1.0) * rxp0_0 * sj0 * x93)) + (((-0.4325) * x90)) +
                                               (((-0.463) * cj2 * x90)) + ((cj0 * rxp0_1 * sj5)) +
                                               (((-1.0) * rxp1_0 * sj0 * x97)) + ((cj0 * cj5 * rxp1_1)));
                                evalcond[3] =
                                    ((-0.0293645) + (((-1.0) * x95 * x98)) + (((-1.0) * r01 * x94 * x97)) +
                                     (((-0.130103) * x99)) + ((x101 * x91)) + ((cj5 * r11 * x96)) +
                                     (((-0.1215325) * x89)) + (((-1.0) * r00 * x93 * x94)) + (((-1.0) * x101 * x95)) +
                                     ((r10 * sj5 * x96)) + (((-0.130103) * x100)) + ((x91 * x98)));
                                if (IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH ||
                                    IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH ||
                                    IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH ||
                                    IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH) {
                                  continue;
                                }
                              }

                              {
                                IkReal j1array[1], cj1array[1], sj1array[1];
                                bool j1valid[1] = {false};
                                _nj1 = 1;
                                IkReal x102 = ((7.11743772241993) * cj3);
                                IkReal x103 = (rxp0_2 * sj5);
                                IkReal x104 = ((1.0) * cj2);
                                IkReal x105 = (cj5 * sj3);
                                IkReal x106 = ((7.11743772241993) * sj3);
                                IkReal x107 = (cj2 * rxp1_2);
                                IkReal x108 = (cj5 * r21 * sj2);
                                IkReal x109 = (cj5 * rxp1_2 * sj2);
                                IkReal x110 = (r20 * sj3 * sj5);
                                IkReal x111 = (cj3 * r20 * sj5);
                                if (IKabs((((cj3 * x108)) + ((cj2 * x102 * x103)) + ((sj2 * x111)) +
                                           ((cj5 * x102 * x107)) + ((sj2 * x103 * x106)) +
                                           (((7.11743772241993) * rxp1_2 * sj2 * x105)) +
                                           (((-1.0) * r21 * x104 * x105)) + (((-1.0) * x104 * x110)))) <
                                        IKFAST_ATAN2_MAGTHRESH &&
                                    IKabs((((cj2 * x111)) + (((7.11743772241993) * x105 * x107)) +
                                           ((r21 * sj2 * x105)) + ((sj2 * x110)) + ((cj2 * x103 * x106)) +
                                           ((cj2 * cj3 * cj5 * r21)) + (((-1.0) * x102 * x109)) +
                                           (((-1.0) * sj2 * x102 * x103)))) < IKFAST_ATAN2_MAGTHRESH &&
                                    IKabs(IKsqr((((cj3 * x108)) + ((cj2 * x102 * x103)) + ((sj2 * x111)) +
                                                 ((cj5 * x102 * x107)) + ((sj2 * x103 * x106)) +
                                                 (((7.11743772241993) * rxp1_2 * sj2 * x105)) +
                                                 (((-1.0) * r21 * x104 * x105)) + (((-1.0) * x104 * x110)))) +
                                          IKsqr((((cj2 * x111)) + (((7.11743772241993) * x105 * x107)) +
                                                 ((r21 * sj2 * x105)) + ((sj2 * x110)) + ((cj2 * x103 * x106)) +
                                                 ((cj2 * cj3 * cj5 * r21)) + (((-1.0) * x102 * x109)) +
                                                 (((-1.0) * sj2 * x102 * x103)))) -
                                          1) <= IKFAST_SINCOS_THRESH)
                                  continue;
                                j1array[0] = IKatan2(
                                    (((cj3 * x108)) + ((cj2 * x102 * x103)) + ((sj2 * x111)) + ((cj5 * x102 * x107)) +
                                     ((sj2 * x103 * x106)) + (((7.11743772241993) * rxp1_2 * sj2 * x105)) +
                                     (((-1.0) * r21 * x104 * x105)) + (((-1.0) * x104 * x110))),
                                    (((cj2 * x111)) + (((7.11743772241993) * x105 * x107)) + ((r21 * sj2 * x105)) +
                                     ((sj2 * x110)) + ((cj2 * x103 * x106)) + ((cj2 * cj3 * cj5 * r21)) +
                                     (((-1.0) * x102 * x109)) + (((-1.0) * sj2 * x102 * x103))));
                                sj1array[0] = IKsin(j1array[0]);
                                cj1array[0] = IKcos(j1array[0]);
                                if (j1array[0] > IKPI) {
                                  j1array[0] -= IK2PI;
                                } else if (j1array[0] < -IKPI) {
                                  j1array[0] += IK2PI;
                                }
                                j1valid[0] = true;
                                for (int ij1 = 0; ij1 < 1; ++ij1) {
                                  if (!j1valid[ij1]) {
                                    continue;
                                  }
                                  _ij1[0] = ij1;
                                  _ij1[1] = -1;
                                  for (int iij1 = ij1 + 1; iij1 < 1; ++iij1) {
                                    if (j1valid[iij1] &&
                                        IKabs(cj1array[ij1] - cj1array[iij1]) < IKFAST_SOLUTION_THRESH &&
                                        IKabs(sj1array[ij1] - sj1array[iij1]) < IKFAST_SOLUTION_THRESH) {
                                      j1valid[iij1] = false;
                                      _ij1[1] = iij1;
                                      break;
                                    }
                                  }
                                  j1 = j1array[ij1];
                                  cj1 = cj1array[ij1];
                                  sj1 = sj1array[ij1];
                                  {
                                    IkReal evalcond[8];
                                    IkReal x112 = IKcos(j1);
                                    IkReal x113 = IKsin(j1);
                                    IkReal x114 = ((0.39260525) * cj2);
                                    IkReal x115 = ((0.03613275) * sj2);
                                    IkReal x116 = (sj0 * sj5);
                                    IkReal x117 = ((1.0) * r10);
                                    IkReal x118 = ((1.0) * cj5);
                                    IkReal x119 = ((1.0) * sj3);
                                    IkReal x120 = ((2.0) * npx);
                                    IkReal x121 = (cj0 * sj5);
                                    IkReal x122 = ((0.1405) * cj2);
                                    IkReal x123 = ((0.1045) * sj3);
                                    IkReal x124 = ((0.4325) * cj2);
                                    IkReal x125 = (py * sj0);
                                    IkReal x126 = (r11 * sj0);
                                    IkReal x127 = (cj0 * r01);
                                    IkReal x128 = ((1.0) * r00);
                                    IkReal x129 = ((0.41024525) * cj2);
                                    IkReal x130 = ((0.1405) * sj2);
                                    IkReal x131 = (cj0 * px);
                                    IkReal x132 = ((0.1045) * cj3);
                                    IkReal x133 = ((0.1045) * cj2);
                                    IkReal x134 = (cj3 * x112);
                                    IkReal x135 = ((0.0903925) * x112);
                                    IkReal x136 = ((2.0) * cj5 * npy);
                                    IkReal x137 = (sj2 * x113);
                                    IkReal x138 = ((1.0) * r20 * sj5);
                                    IkReal x139 = (sj3 * x113);
                                    IkReal x140 = (cj2 * x112);
                                    IkReal x141 = (cj2 * x113);
                                    IkReal x142 = (sj3 * x112);
                                    IkReal x143 = (sj2 * x112);
                                    IkReal x144 = (cj3 * x113);
                                    IkReal x145 = ((0.1405) * x144);
                                    evalcond[0] = ((((-1.0) * r21 * x118)) + ((cj3 * x137)) + ((cj2 * x134)) +
                                                   (((-1.0) * x138)) + ((sj2 * x142)) + (((-1.0) * x119 * x141)));
                                    evalcond[1] =
                                        (((x122 * x144)) + ((x122 * x142)) + (((-1.0) * rxp0_2 * sj5)) +
                                         (((-1.0) * rxp1_2 * x118)) + ((x130 * x139)) + (((-1.0) * x130 * x134)));
                                    evalcond[2] =
                                        ((((-1.0) * x118 * x127)) + (((-1.0) * x118 * x126)) +
                                         (((-1.0) * x116 * x117)) + ((sj2 * x134)) + (((-1.0) * x121 * x128)) +
                                         (((-1.0) * cj3 * x141)) + (((-1.0) * x119 * x140)) + (((-1.0) * x119 * x137)));
                                    evalcond[3] = ((((0.4325) * x137)) + ((x112 * x124)) + ((x123 * x143)) +
                                                   (((-1.0) * x123 * x141)) + (((0.463) * x112)) + (((-1.0) * pz)) +
                                                   ((x132 * x137)) + ((x132 * x140)));
                                    evalcond[4] =
                                        ((((-1.0) * x122 * x139)) + (((-1.0) * rxp0_1 * x116)) + ((x122 * x134)) +
                                         (((-1.0) * rxp0_0 * x121)) + (((-1.0) * cj0 * rxp1_0 * x118)) +
                                         ((x130 * x144)) + ((x130 * x142)) + (((-1.0) * rxp1_1 * sj0 * x118)));
                                    evalcond[5] =
                                        ((((-1.0) * x123 * x137)) + (((-1.0) * x113 * x124)) + (((0.4325) * x143)) +
                                         (((-1.0) * x132 * x141)) + (((-1.0) * x123 * x140)) + (((-0.463) * x113)) +
                                         (((-1.0) * x131)) + (((-1.0) * x125)) + ((x132 * x143)));
                                    evalcond[6] =
                                        ((((-1.0) * pp * r21 * x118)) + (((-0.400495) * x139)) +
                                         (((-0.400495) * x134)) + ((pz * x136)) + (((-1.0) * cj2 * x135)) +
                                         ((x115 * x144)) + (((-0.096767) * x112)) + (((-0.0903925) * x137)) +
                                         (((-1.0) * x114 * x134)) + ((pz * sj5 * x120)) + (((-1.0) * pp * x138)) +
                                         (((-1.0) * x129 * x139)) + (((-0.01849275) * sj2 * x142)));
                                    evalcond[7] =
                                        ((((0.096767) * x113)) + (((0.0903925) * x141)) + (((-1.0) * sj2 * x135)) +
                                         (((-1.0) * pp * x116 * x117)) + (((-0.400495) * x142)) +
                                         (((0.400495) * x144)) + (((-1.0) * x129 * x142)) + ((x131 * x136)) +
                                         ((py * x116 * x120)) + (((0.01849275) * sj3 * x137)) + ((x125 * x136)) +
                                         (((-1.0) * pp * x121 * x128)) + ((px * x120 * x121)) + ((x115 * x134)) +
                                         (((-1.0) * pp * x118 * x126)) + (((-1.0) * pp * x118 * x127)) +
                                         ((x114 * x144)));
                                    if (IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH ||
                                        IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH ||
                                        IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH ||
                                        IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH ||
                                        IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH ||
                                        IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH ||
                                        IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH ||
                                        IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH) {
                                      continue;
                                    }
                                  }

                                  {
                                    IkReal j4array[1], cj4array[1], sj4array[1];
                                    bool j4valid[1] = {false};
                                    _nj4 = 1;
                                    j4array[0] = 0;
                                    sj4array[0] = IKsin(j4array[0]);
                                    cj4array[0] = IKcos(j4array[0]);
                                    if (j4array[0] > IKPI) {
                                      j4array[0] -= IK2PI;
                                    } else if (j4array[0] < -IKPI) {
                                      j4array[0] += IK2PI;
                                    }
                                    j4valid[0] = true;
                                    for (int ij4 = 0; ij4 < 1; ++ij4) {
                                      if (!j4valid[ij4]) {
                                        continue;
                                      }
                                      _ij4[0] = ij4;
                                      _ij4[1] = -1;
                                      for (int iij4 = ij4 + 1; iij4 < 1; ++iij4) {
                                        if (j4valid[iij4] &&
                                            IKabs(cj4array[ij4] - cj4array[iij4]) < IKFAST_SOLUTION_THRESH &&
                                            IKabs(sj4array[ij4] - sj4array[iij4]) < IKFAST_SOLUTION_THRESH) {
                                          j4valid[iij4] = false;
                                          _ij4[1] = iij4;
                                          break;
                                        }
                                      }
                                      j4 = j4array[ij4];
                                      cj4 = cj4array[ij4];
                                      sj4 = sj4array[ij4];

                                      {
                                        std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
                                        vinfos[0].jointtype = 1;
                                        vinfos[0].foffset = j0;
                                        vinfos[0].indices[0] = _ij0[0];
                                        vinfos[0].indices[1] = _ij0[1];
                                        vinfos[0].maxsolutions = _nj0;
                                        vinfos[1].jointtype = 1;
                                        vinfos[1].foffset = j1;
                                        vinfos[1].indices[0] = _ij1[0];
                                        vinfos[1].indices[1] = _ij1[1];
                                        vinfos[1].maxsolutions = _nj1;
                                        vinfos[2].jointtype = 1;
                                        vinfos[2].foffset = j2;
                                        vinfos[2].indices[0] = _ij2[0];
                                        vinfos[2].indices[1] = _ij2[1];
                                        vinfos[2].maxsolutions = _nj2;
                                        vinfos[3].jointtype = 1;
                                        vinfos[3].foffset = j3;
                                        vinfos[3].indices[0] = _ij3[0];
                                        vinfos[3].indices[1] = _ij3[1];
                                        vinfos[3].maxsolutions = _nj3;
                                        vinfos[4].jointtype = 1;
                                        vinfos[4].foffset = j4;
                                        vinfos[4].indices[0] = _ij4[0];
                                        vinfos[4].indices[1] = _ij4[1];
                                        vinfos[4].maxsolutions = _nj4;
                                        vinfos[5].jointtype = 1;
                                        vinfos[5].foffset = j5;
                                        vinfos[5].indices[0] = _ij5[0];
                                        vinfos[5].indices[1] = _ij5[1];
                                        vinfos[5].maxsolutions = _nj5;
                                        std::vector<int> vfree(0);
                                        solutions.AddSolution(vinfos, vfree);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return solutions.GetNumSolutions() > 0;
  }
};

/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree,
                          IkSolutionListBase<IkReal>& solutions) {
  IKSolver solver;
  return solver.ComputeIk(eetrans, eerot, pfree, solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree,
                           IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
  IKSolver solver;
  return solver.ComputeIk(eetrans, eerot, pfree, solutions);
}

IKFAST_API const char* GetKinematicsHash() {
  return "<robot:GenericRobot - utra6_1000 (587031e3e68bd3707c1001a5c6110914)>";
}

IKFAST_API const char* GetIkFastVersion() { return "0x1000004b"; }

#ifdef IKFAST_NAMESPACE
}  // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif

#endif
